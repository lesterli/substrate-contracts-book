<!DOCTYPE HTML>
<html lang="zh_CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate Contracts Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contracts/overview.html"><strong aria-hidden="true">1.1.</strong> 合约综述</a></li><li class="chapter-item expanded "><a href="contracts/model.html"><strong aria-hidden="true">1.2.</strong> 合约模型</a></li><li class="chapter-item expanded "><a href="contracts/wasm_first_step.html"><strong aria-hidden="true">1.3.</strong> Wasm初步</a></li></ol></li><li class="chapter-item expanded "><a href="pallet-contracts/introduction.html"><strong aria-hidden="true">2.</strong> pallet-contracts 合约模块</a></li><li class="chapter-item expanded "><a href="ink/introduction.html"><strong aria-hidden="true">3.</strong> ink!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ink/tutorial.html"><strong aria-hidden="true">3.1.</strong> ink! tutorial</a></li><li class="chapter-item expanded "><a href="ink/framework.html"><strong aria-hidden="true">3.2.</strong> ink! 框架</a></li><li class="chapter-item expanded "><a href="ink/edsl-basic.html"><strong aria-hidden="true">3.3.</strong> ink! eDSL基础元素</a></li><li class="chapter-item expanded "><a href="ink/call-contracts.html"><strong aria-hidden="true">3.4.</strong> ink! 跨合约调用</a></li><li class="chapter-item expanded "><a href="ink/ink-solidity.html"><strong aria-hidden="true">3.5.</strong> ink! 与solidity的对比</a></li><li class="chapter-item expanded "><a href="ink/cargo-contract.html"><strong aria-hidden="true">3.6.</strong> cargo-contract</a></li><li class="chapter-item expanded "><a href="ink/trap.html"><strong aria-hidden="true">3.7.</strong> ink! 当前的坑</a></li></ol></li><li class="chapter-item expanded "><a href="ask/introduction.html"><strong aria-hidden="true">4.</strong> Ask!</a></li><li class="chapter-item expanded "><a href="solang/introduction.html"><strong aria-hidden="true">5.</strong> Solang</a></li><li class="chapter-item expanded "><a href="redspot/introduction.html"><strong aria-hidden="true">6.</strong> Redspot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="redspot/tutorial.html"><strong aria-hidden="true">6.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="redspot/console.html"><strong aria-hidden="true">6.2.</strong> 控制台console</a></li></ol></li><li class="chapter-item expanded "><a href="europa/introduction.html"><strong aria-hidden="true">7.</strong> Europa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="europa/tutorial.html"><strong aria-hidden="true">7.1.</strong> Europa tutorial</a></li><li class="chapter-item expanded "><a href="europa/features.html"><strong aria-hidden="true">7.2.</strong> Europa 特性</a></li></ol></li><li class="chapter-item expanded "><a href="patract/introduction.html"><strong aria-hidden="true">8.</strong> Patract</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                        
                        <button id="language-toggle" class="icon-button" type="button" title="Select language" aria-label="Select language" aria-haspopup="true" aria-expanded="false" aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="language-popup" aria-label="Languages" role="menu">
                          
                            <li role="none"><a href="../en_US/print.html"><button role="menuitem" class="language" id="light">English</button></a></li>
                          
                            <li role="none"><a href="../zh_CN/print.html"><button role="menuitem" class="language" id="light">中文</button></a></li>
                          
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Substrate 合约书</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#substrate-合约书" id="substrate-合约书">Substrate 合约书</a></h1>
<h2><a class="header" href="#介绍" id="介绍">介绍</a></h2>
<p>本书用于介绍 Substrate 中与合约体系相关的一系列知识。</p>
<p>本书由 Patract (<a href="https://patract.io/">https://patract.io/</a>) @ <a href="https://github.com/patractlabs">patractlabs</a> 主导编写，由 Aten @ <a href="https://github.com/atenjin">atenjin</a> 负责。</p>
<p>本书仓库位于 <a href="https://github.com/patractlabs/substrate-contracts-book">https://github.com/patractlabs/substrate-contracts-book</a>，欢迎有志之士一起为本书做出贡献。</p>
<p>本书主体包含三类：</p>
<ul>
<li>运行合约的合约平台（模块）</li>
<li>编写合约的语言</li>
<li>帮助合约开发的工具们</li>
</ul>
<p>其中由于<code>pallet-evm</code>（即EVM/solidity体系的合约）在以太坊生态中已有比较丰富的资料，故不会在本合约书中当做重点讲解。而另外的合约体系如<code>pallet-actor</code>，或<code>libra</code>移植合约平台等皆处于比较早期的研究阶段，因此也不会作为本书的重点。</p>
<p><strong>本书当前主要以<code>pallet-contracts</code> （即WASM合约）作为主体进行介绍。</strong></p>
<p>因此本书内容包含：</p>
<ul>
<li>运行合约的合约平台（模块）
<ul>
<li><code>pallet-contracts</code></li>
</ul>
</li>
<li>编写合约的语言
<ul>
<li><code>ink!</code></li>
<li><code>Ask!</code></li>
<li><code>Solang</code></li>
</ul>
</li>
<li>帮助合约开发的工具们
<ul>
<li><code>Redspot</code></li>
<li><code>Europa</code></li>
<li><code>Elara</code></li>
</ul>
</li>
</ul>
<p>为了让合约开发者更好的理解<code>pallet-contracts</code>模块与WASM合约的运行方式，本书也会涉及一些WASM的介绍以及区块链合约模型的介绍。</p>
<h1><a class="header" href="#合约综述" id="合约综述">合约综述</a></h1>
<p>区块链运行合约的模型从本质上可以认为是 “区块链的环境（分布式共识系统）”+“能运行一段逻辑的平台”，例如</p>
<ul>
<li>比特币的模型可以拆成区块模型/PoW + 比特币脚本</li>
<li>以太坊的模型可以拆成区块，状态模型/PoW + EVM</li>
<li>Substrate的模型可以拆成区块，状态模型/Bft共识 + Runtime</li>
</ul>
<p>因此一般来说，我们可以将区块链的模型拆成</p>
<ul>
<li>运行区块链的底层系统：提供分布式可信环境</li>
<li>链的业务逻辑：运行在这个可信环境中</li>
</ul>
<p>而由于区块链系统的特性，要求对<strong>相同的代码，相同的状态，执行的结果一定需要一致</strong>，因此在提供“链的业务逻辑”这一层，为了保证执行结果的一致性，要求整个运行环境必须是“<strong>无副作用的</strong>”，因此不会因为运行节点的不一致（指不是同一个节点）而导致运行的结果不一致。</p>
<p>因此为了保证这种特性，绝大部分区块链都会采用<strong>沙盒/虚拟机的模型</strong>加上裁剪一些功能来做到。</p>
<p>“运行合约的平台”即是一种链的业务逻辑，且这种业务逻辑<strong>特殊在其上面可运行的代码是开放的，合约内容不受链本身控制</strong>。因此对于这种情况，更需要一种“沙盒”的环境来隔离各个合约之间的运行。</p>
<h2><a class="header" href="#什么是沙盒虚拟机" id="什么是沙盒虚拟机">什么是沙盒（虚拟机）</a></h2>
<p>“沙盒”在计算机领域中的概念很广泛，而在区块链中，一般而言沙盒都会由一个虚拟机去运行（因为使用虚拟机最容易模拟沙盒的环境）。</p>
<p>因此不同的链就会采用不同的虚拟机来运行合约的沙盒：</p>
<ul>
<li>
<p>Ethereum：</p>
<p>Gavin Wood 写的黄皮书构了的EVM的模型，创建了EVM虚拟机的概念并拟定了EVM的OP_CODE。之后设计了Solidity编译到OP_CODE，才有了Ethereum的整个生态。相当于Ethereum处理区块链的合约沙盒模型，从零到一构建所有设施。因此Solidity的语法以及EVM能做的事对比现在的区块链显得<strong>十分简陋</strong>（例如solidity的语法，EVM的栈深限制等等），但其作为<strong>先行者开创了区块链合约虚拟机模型先河</strong>。</p>
</li>
<li>
<p>Fabric:</p>
<p>作为联盟链，在使用场景上与公有链存在区别。因此Fabric提出链码的概念，并将链码运行在了docker中。docker就是比较重的一种虚拟机（相对于EVM而言），因此与EVM比较，Fabric的链码可以做到比Solidity更多的事，当是相对的，其运行的代价与EVM相比就高得多。</p>
</li>
<li>
<p>EOS：</p>
<p>EOS采用了Wasm作为合约的虚拟机，也是当时EOS的卖点。相比于运行Solidity的EVM，EOS的Wasm虚拟机的运行效率高了许多，以C++作为编译到Wasm的语言也天然拉近了许多传统的开发者。EOS作为Wasm虚拟机的先行者，在当时已经体现出Wasm相对于EVM的优势，但是由于其合约模型的设计（见下一章节）的缺陷以及当时环境的约束，再加上EOS并非真正的去中心化系统，导致EOS并没有很好的发挥出Wasm合约系统的能力。</p>
</li>
<li>
<p>Substrate 的<code>pallet-contracts</code>：</p>
<p><code>pallet-contracts</code>采用了Wasm虚拟机来运行合约，当前出于安全考量只采用了<code>Wasmi</code>解释器来执行Wasm。但其合约模型与EVM的合约模型近似（见下一章节）。Wasm虚拟机与EVM同样具有启动快，随用随丢的特性，具备高性能和高扩展性的同时又不像docker， JVM一样太过庞大。因此Wasm慢慢在除了浏览器环境以外的更多场景被采用，例如边缘计算，热更新等等。所以当前越来越多的新区块链在需要一个沙盒环境时会将Wasm虚拟机作为主要方案。另一方面Wasm也具备从不同语言编译到Wasm的特性，例如<code>rust</code>，<code>assemblyscript</code>，<code>c++</code>等等，可以吸引到各类开发者加入到合约开发过程中。</p>
</li>
<li>
<p>其他：</p>
<p>其他区块链为了完成这个“沙盒”的目标也会有各自的方案，有的联盟链采用了裁剪过的JVM，有的公链采用了<code>RISC-V</code>的虚拟机，有的链采用了从零设计一个虚拟机（如libra）。这些方案各自有各自的需求与特性，但从模型上而言，无论什么方案，最终目标都是为了提供一个虚拟机环境以运行合约沙盒。</p>
</li>
</ul>
<h2><a class="header" href="#运行合约的沙盒" id="运行合约的沙盒">运行合约的沙盒</a></h2>
<p>上文已描述链的业务逻辑大部分会运行于沙盒的系统中，且“运行合约”这种业务逻辑更是要需要沙盒隔离。而另一方面Substrate的runtime就是一个沙盒环境（运行于Wasm中），因此在Substrate的合约模块（<code>pallet-emv</code>，<code>pallet-contracts</code>），就是需要在一个沙盒环境中运行另一个沙盒，如下图所示：</p>
<p><img src="contracts/./imgs/overview_module.jpg" alt="overview" /></p>
<p>其中：</p>
<ul>
<li>左边是以太坊模型，表示每运行一个合约，需要在链的平台上启动一个EVM虚拟机去运行</li>
<li>右边是Substrate模型，我们当前已知Substrate的链的业务逻辑是运行在Wasm虚拟机当中的：
<ul>
<li><code>pallet-EVM</code>：将以太坊的EVM编译到了Runtime Wasm当中，因此每运行一个合约实际上与以太坊一致，创建了一个EVM虚拟机去运行。如果链是以Wasm形态运行，即是在Wasm虚拟机中生成了一个EVM虚拟机去运行。</li>
<li><code>pallet-contracts</code>：Wasm合约使用Wasm虚拟机运行合约，与<code>pallet-evm</code>不同的地方是，如果链是以Wasm形态运行，Wasm合约的虚拟机是跳出当前Runtime Wasm虚拟机重新创建了一个新的Wasm虚拟机运行。
<ul>
<li>当前（在substrate的提交之前 <a href="https://github.com/paritytech/substrate/commit/0b0d124d5f9be89f614f2be8e9da038fcb9f540e"><code>0b0d124d</code></a>）Runtime的Wasm虚拟机推荐采用的是<code>Wasmtime</code>而<code>pallet-contracts</code>合约<strong>只能</strong>采用<code>Wasmi</code>。</li>
<li><code>pallet-contracts</code>也可以使用<code>Wasmtime</code>执行，但是当前parity认为<code>Wasmtime</code>不可控性比较大，因此暂时还未采用<code>Wasmtime</code>。当前他们有相关计划，也有原型代码来使用<code>Wasmtime</code>运行<code>pallet-contracts</code>的合约。（注1）</li>
</ul>
</li>
</ul>
</li>
<li>总之运行合约的过程中，大部分链都采用了一种沙盒的模型去运行合约。而对于EVM，<code>pallet-contracts</code>模型而言，是<strong>每运行一个合约就会创建一个虚拟机</strong>。</li>
</ul>
<h2><a class="header" href="#注解" id="注解">注解</a></h2>
<ol>
<li><code>Wasmtime</code>是实现了JIT的Wasm虚拟机，而<code>Wasmi</code>是纯解释器型的Wasm虚拟机。</li>
<li><code>Wasmtime</code>的执行效率比<code>Wasmi</code>高很多。</li>
</ol>
<h1><a class="header" href="#合约模型" id="合约模型">合约模型</a></h1>
<p>在已经具备合约及合约沙盒的概念后，我们就可以开始讨论合约模型的概念了。</p>
<p>合约沙盒只是代表运行合约的环境，而合约是以什么方式运行的，合约和合约是怎么交互的，合约是怎么与链的数据互动的，这些问题就归属于合约模型问题。</p>
<p>换句话说，<strong>合约模型就是合约是以什么模型运行在合约沙盒/虚拟机中的</strong>。</p>
<p><img src="contracts/./imgs/model.jpg" alt="" /></p>
<p>如图所示，合约模型与合约虚拟机本质上是可以解耦的，其中关系只存在合约虚拟机是否能支持上层所需要的合约模型，例如：</p>
<ul>
<li>Bitcoin 的虚拟机就是比特币脚本的栈执行器，由于执行器设计是非图灵完备的OP_CODE，因此对于上层的合约模型只能支持Bitcoin的脚本。</li>
<li>Ethereum 跟随Bitcoin的灵感，设计了具备图灵完备的OP_CODE，即EVM虚拟机（Ethereum Virtual Machine）。但是EVM的OP_CODE比较简陋，且只有栈的设计，没有堆的概念。但是EVM引入了读写状态的OP_CODE，因此从虚拟机机制上对合约模型可以支持状态模型。因此EVM也被看做一个执行状态转换的状态转换机（如Gavin Wood撰写的以太坊黄皮书中所描述的）。状态模型实际上是比较通用的抽象模型，绝大多数模型都可以用状态模型模拟（如在状态模型中构建UTXO模型），因此从理论上来说，只要继续完善EVM的OP_CODE，EVM的上层同样可以构建出其他合约模型。</li>
<li>libra 认为区块链的核心在于资产的处理，因此提出了Move的虚拟机模型（Move Virtual Machine (MVM)）来从虚拟机上限定合约的模型，可以理解为是一种特化逻辑过的OP_CODE集合。因此MVM的上层只能运行Move模型。</li>
</ul>
<p>通过以上讨论，我们可以认识到合约模型的概念，并且理解到虚拟机对上层合约模型的限制，因此接下来就可以讨论Wasm虚拟机可以运行的合约模型以及<code>pallet-contracts</code>的合约模型构成。</p>
<h2><a class="header" href="#wasm-虚拟机" id="wasm-虚拟机">Wasm 虚拟机</a></h2>
<p>Wasm是一种在基于栈的虚拟机上运行的二进制的指令格式。（WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine, from <a href="https://webassembly.org/">https://webassembly.org/</a>）因此Wasm的模型和主流计算机程序的模型结构比较相似。另一方面Wasm被设计成为了一种比较通用的形式，且设计了WASI并支持了运行环境自由定义<code>host function</code>，因此虽然Wasm从浏览器发展而来，但是当前的使用场景已经不限于浏览器，开始在边缘计算，热更新，Serverless平台等发挥效果。</p>
<p>若以指令的完备性来衡量一个虚拟机的能力，则EVM处于半成品的程度，限制多且不够灵活；而JVM，Wasm虚拟机则是比较完备的，限制少，功能性强。另一方面指令设计的合理性一定程度也会影响虚拟机的执行效率，同时虚拟机采用的实现方案也会对执行效率产生比较大的影响。</p>
<p>例如EVM当前只能以解释器（interpreter）的形式运行，并且当前的实现过程体（go, c++等版本）中没有看到针对解释器的优化，执行效率比较底下，而 JVM, Wasm等虚拟机有采用JIT的模式的实现，执行效率相当高甚至逼近本地执行的性能。</p>
<blockquote>
<p>注：<code>pallet-contracts</code>当前只能使用<code>wasmi</code>（解释器）执行Wasm代码，因此合约的执行性能比不上能使用<code>wasmtime</code>的Runtimed的执行。</p>
</blockquote>
<p>而同时，Wasm虚拟机相比于JVM等虚拟机，十分轻便（Lightweight），快速，可定制性强，<strong>且<code>host function</code>的功能给予了Wasm虚拟机与宿主之间交互的通道</strong>，因此和其他虚拟机相比，将Wasm虚拟机作为区块链合约沙盒与链的功能结合在一起比较容易。</p>
<p>另一方面在笔者看来，Wasm是处于底层代码与上层代码之间比较好的一个抽象层，且其复杂性与完备性也远超于EVM，因此比较适合区块链合约领域的需求。</p>
<p>因此Wasm虚拟机提供的沙盒环境在满足合约沙盒的前提下还满足以下2点要求：</p>
<ul>
<li>指令完备，功能性丰富，执行效率高</li>
<li>有适合的的接口能与宿主（这里指代运行Wasm的环境，即链）交互，方面宿主提供需要的功能。</li>
</ul>
<h2><a class="header" href="#evm-的合约模型" id="evm-的合约模型">EVM 的合约模型</a></h2>
<p>由于Ethereum是存储状态的区块链，因此EVM的合约模型理所应当的需要基本读写状态的功能。如果把每次合约运行的过程看做一次程序的启动到执行结束的过程，那么状态数据的变化就对应着这个程序需要持久化数据的变化。</p>
<p>因此对于读写状态，以太坊的EVM提供了<code>SLOAD</code>和<code>SSTORE</code>两个指令。</p>
<p>另一方面以太坊描述一个账户使用了“账户模型”，即将合约和调用合约的用户都看做了一个账户，在这个账户下存在<code>balance</code>等概念，因此EVM提供了<code>CALLER</code>，<code>ORIGIN</code>，<code>CALLVALUE</code>等等一系列指令来描述这种模型。</p>
<p>同时由于在EVM的抽象体系中，认为合约与用户是一致的，因此出现了“合约调用合约”的模型，即<code>CALL</code>，<code>DELEGATECALL</code>等指令，由此带来了合约的可组合性，造就了Ethereum繁荣的生态。而在EVM中，一个合约依托于一个EVM进行运行，因此合约调用合约是在一个EVM中启动了另一个EVM并加载指令进行执行。</p>
<p>当然EVM虚拟机设计的初衷就是为了解决比特币脚本的非图灵完备问题，为了解决这个问题并保证停机问题不发生，引入了指令的Gas计费模型</p>
<p>因此总结以上可以得到，EVM的合约模型具备以下特性：</p>
<ol>
<li>处理数据的模型是状态机模型，状态的变更靠外界调用触发（类比于调用了状态变更函数的过程）；</li>
<li>合约模型中需要链相关的特性；</li>
<li>将合约与用户看做一致，允许合约调用合约；</li>
<li>引入指令计费模型。</li>
</ol>
<h2><a class="header" href="#pallet-contracts的合约模型" id="pallet-contracts的合约模型"><code>pallet-contracts</code>的合约模型</a></h2>
<p>这里直接下结论：<strong><code>pallet-contracts</code>虽然使用了Wasm虚拟机来执行代码，但是其合约模型基本与EVM合约模型一致</strong>。</p>
<p>也就是说<code>pallet-contracts</code>的合约模型同样具备以下4点特性：</p>
<ol>
<li>处理数据的模型是状态机模型；</li>
<li>合约模型中需要链相关的特性；</li>
<li>将合约与用户看做一致，允许合约调用合约；</li>
<li>引入指令计费模型。</li>
</ol>
<p>并且，在以上4种特性的基础上，增加了“存储租赁模型”：</p>
<ul>
<li><code>Rent</code>存储租赁计费。</li>
</ul>
<p>在上文已经称述了合约执行的环境和合约模型是可以解耦的，EVM由于设计的比较早还没有解耦这个层次的概念，因此在指令中<code>SLOAD</code>，<code>SSTORE</code>及类似和链相关的指令是与EVM其他指令合并一起的。而Wasm本来并非为区块链设计，因此一定不存在这些和链环境相关的指令。</p>
<p>因此Wasm的<code>host function</code>即是用来完成这件事情的。链作为<code>host</code>宿主，只需要把<strong>他认为合约可能会用到的方法</strong>提供给Wasm虚拟机，让他导入这些函数对象，在合约的执行过程中即可以使用。因此通过<code>host function</code>，<code>pallet-contracts</code>合约模块就可以具备1，2，4功能，并将提供3需要的部分功能，同时第5点特性（租赁计费）也可以引入。</p>
<p>并且其中第3点功能的实现方式也与EVM一致，当出现合约调用合约的部分时，通过<code>host function</code>从Wasm回到了<code>pallet-contracts</code>模块，并启动了一个新的Wasm虚拟机去执行被调用的合约。（该部分在以后的文章中会描述）</p>
<p>因此总结而言，<code>pallet-contracts</code>的合约模型具备如下特性：</p>
<ol>
<li>合约模型与EVM的合约模型一致，并在此基础上增加了存储计费模型</li>
<li>与链交互的实现通过Wasm的<code>host function</code>特性实现</li>
</ol>
<h2><a class="header" href="#使用wasm虚拟机实现其他合约模型" id="使用wasm虚拟机实现其他合约模型">使用Wasm虚拟机实现其他合约模型</a></h2>
<p>刚才简要描述了<code>pallet-contracts</code>是如何在Wasm虚拟机上实现合约模型的，由于前文已经解释了虚拟机与合约模型是可以解耦的，因此实际上在Wasm虚拟机上同样可以实现其他的合约模型。</p>
<p>例如我们可以考虑将Move虚拟机也移植到Wasm虚拟机中，其有两种可能的实现方式：</p>
<ol>
<li>
<p>类比于将EVM的实现体在Runtime的Wasm环境运行，可以将MVM的实现体也编译成Wasm的形式（例如命名为<code>pallet-mvm</code>），在Runtime Wasm中运行。</p>
<p>基于这种实现，Move依然可以按正常方式编译，并和Solidity的编译结果运行于<code>pallet-evm</code>一致，将Move的编译结果运行在例如<code>pallet-mvm</code>的平台上。</p>
</li>
<li>
<p>将MVM与所有权，链相关的特性抽象一层，做成和<code>pallet-contracts</code>的形式，并设计将Move语言编译的中间码IR编译到Wasm。</p>
<p>基于这种实现，可以将Move编译成为Wasm，并在Wasm虚拟机中运行。</p>
</li>
</ol>
<h2><a class="header" href="#其他合约模型" id="其他合约模型">其他合约模型</a></h2>
<h3><a class="header" href="#eos的合约模型" id="eos的合约模型">EOS的合约模型</a></h3>
<p>EOS的合约模型与EVM类似，同时强化了账户模型的概念。因此EOS使用Wasm的方式也是基于Wasm的执行，并通过<code>host function</code>引入与链相关的功能。</p>
<p>EOS和EVM模型的主要区别在于，EOS的合约调用合约的过程是以发交易的形态调用，并且EOS的资源模型是抵押模型。当前普遍认为正是EOS的抵押模型最后导致EOS没有走向成功。</p>
<h3><a class="header" href="#异步合约模型" id="异步合约模型">异步合约模型</a></h3>
<p><code>pallet-actor</code>是 substrate 尝试实现异步合约模型的一个开端，当前没有什么进展。<code>pallet-actor</code>的模型打算使用Wasm虚拟机作为运行环境，并在此基础上添加异步的功能以提升性能。</p>
<p>当前也有其他少数对异步合约模型的研究，但是皆处于比较初步的阶段。</p>
<h1><a class="header" href="#wasm简要介绍" id="wasm简要介绍">WASM简要介绍</a></h1>
<h2><a class="header" href="#wasm与合约模型的关联" id="wasm与合约模型的关联">WASM与合约模型的关联</a></h2>
<p><img src="contracts/./imgs/wasm.jpg" alt="" /></p>
<h1><a class="header" href="#pallet-contracts-合约模块" id="pallet-contracts-合约模块">pallet-contracts 合约模块</a></h1>
<p><code>pallet-contracts</code>合约模块, 一般称呼为<a href="https://substrate.dev/docs/en/knowledgebase/smart-contracts/contracts-pallet">“Contracts Pallet”</a> 或者 “FRAME Contracts pallet”，又或者称呼为“Substrate Smart Contracts”，是parity官方研发的Wasm合约模块。</p>
<p>依据Substrate knowledgebase的介绍，Contracts Pallet具备如下特性：</p>
<ul>
<li>Are inherently safer to the network.</li>
<li>Have built in economic incentives against abuse.</li>
<li>Have computational overhead to support graceful failures in logic.</li>
<li>Have a lower bar to entry for development.</li>
<li>Enable fast pace community interaction through a playground to write new logic.</li>
</ul>
<h1><a class="header" href="#ink" id="ink">ink</a></h1>
<p>ink! is an eDSL to write WebAssembly based smart contracts using the Rust programming language. The compilation target are blockchains built on the Substrate framework.</p>
<p>ink! 是 parity 官方编写的，可以提供一种 eDSL 的方式编写 Rust 合约，并编译为 Wasm 运行于 Contracts Pallet 模块上。</p>
<p>虽然 ink!自称为一种写合约的 eDSL，但是笔者更倾向于认为 ink!是使用 Rust 语言编写符合能满足 Contracts Pallet 运行的合约框架。</p>
<p>例如对于 EVM 而言，若把 EVM 的指令集看做一种规范（EVM 的指令集已经包含了 EVM 合约模型的信息），那么只要能编译到 EVM 指令集的语言都可以称为能运行在 EVM 上的合约语言，例如：</p>
<ul>
<li>Solidity</li>
<li>Vyper</li>
</ul>
<p>而 ink!这里同理。Contracts Pallet 要求是能满足运行 Contracts Pallet 合约模型的 Wasm 代码，因此任何能编译成满足这个 Wasm 合约模型的框架/语言/库都可以称为 Contracts Pallet 的合约语言。</p>
<p>ink!就是使用 Rust 语言，并在此基础上通过 Rust 的<strong>卫生宏系统</strong>设计了一套 eDSL，并使用该 eDSL 编写能满足 Contracts Pallet 要求的 Rust 代码。除 eDSL 之外，ink!还提供了适用于合约模型的<strong>存储集合类型</strong>，生成 Metadata（对应于 Solidity 的 ABI）等工具库。</p>
<p>ink!的官方文档见：</p>
<ul>
<li><a href="https://substrate.dev/docs/en/knowledgebase/smart-contracts/ink-fundamentals">ink! Concepts</a></li>
<li><a href="https://substrate.dev/substrate-contracts-workshop/#/">ink! Smart Contracts Tutorial</a></li>
<li><a href="https://paritytech.github.io/ink-docs/">ink! Documentation Portal</a></li>
</ul>
<h2><a class="header" href="#ink-到-contracts-pallet-的过程" id="ink-到-contracts-pallet-的过程">ink! 到 Contracts pallet 的过程</a></h2>
<p>parity 官方文档中提供了示例图：
<img src="https://paritytech.github.io/ink-docs/img/how-it-works.svg" alt="https://paritytech.github.io/ink-docs/how-it-works" /></p>
<p>由此图可知，编写 ink!合约并部署的过程需要</p>
<ul>
<li>ink! 依赖库：提供 ink!的 eDSL 框架以及提供相应的依赖组件</li>
<li>cargo-contract: 编译 ink!合约的工具</li>
<li>SDK：与链交互并将合约部署到链上的 SDK，parity 官方主要提供了<code>polkadot.js</code>，Patract 提供了 Himalia 工具包，包含<code>go</code>，<code>java</code>，<code>python</code>，<code>C#</code>的 SDK</li>
</ul>
<p>本章节将主要介绍 ink!以及<code>cargo-contract</code>的信息，关于 SDK 的信息放在后续章节介绍。</p>
<h1><a class="header" href="#ink-tutorial" id="ink-tutorial">ink! tutorial</a></h1>
<p>TODO</p>
<h1><a class="header" href="#ink-框架" id="ink-框架">ink! 框架</a></h1>
<p>ink!的所有主体功能都实现于 <a href="https://github.com/paritytech/ink/tree/master/crates"><code>ink/crates</code></a> 目录下：</p>
<ul>
<li>crates:
<ul>
<li>allocator：与Wasm相关，定义allocator，开发者绝大部分情况下无需关心</li>
<li>env：提供和链相交互的组件，总结来说就是和链相关的部分都会放在这里，包含
<ul>
<li>host function 部分</li>
<li>部分需要导入的类型、trait定义</li>
<li>event 的topic</li>
</ul>
</li>
<li>lang：eDSL过程宏的定义组件，合约的规范由这个地方决定</li>
<li>metadata：生成metadata的组件</li>
<li>prelude：合约编写过程中需要预先导入的包，包含一些标准库</li>
<li>primitives：操作状态存储的指针，开发者绝大部分情况下无需关心</li>
<li>storage：提供链存储的分配模型以及提供一些预定义好的存储集合类型</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#ink-edsl基础元素" id="ink-edsl基础元素">ink! eDSL基础元素</a></h1>
<p>ink! eDSL设计的元素与Solidity的元素其实比较近似，因为Contracts Pallet的合约模型结构和EVM的合约模型就是比较近似的。</p>
<p>因此ink!的设计可以找到很多和Solidity相似的影子（Substrate 的 Runtime 设计同理）。后文描述ink特性时会尝试跟Solidity的特性进行对比，方便读者理解。</p>
<h2><a class="header" href="#edsl-的元素" id="edsl-的元素">eDSL 的元素</a></h2>
<p>由ink!文档或ink!提供的example，代码可以看出，ink!在Contracts Pallet的模型上，同样提出了以下三点基础元素：</p>
<ul>
<li><code>constructor</code>/<code>message</code></li>
<li><code>storage</code></li>
<li><code>event</code></li>
</ul>
<p>不过由于Rust过程宏的设计关系，可以看到ink!首先要求一个合约需要处于一个<code>mod</code>下，并且在这个<code>mod</code>的上面添加上<code>#[ink::contract]</code>宏：</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    // ...
}
</code></pre>
<p>这样，相当于告知ink!从这个mod里面的东西就是要依据ink的eDSL处理的部分。</p>
<h3><a class="header" href="#inkcontract" id="inkcontract"><code>#[ink::contract]</code></a></h3>
<p>因此当遇到宏<code>#[ink::contract]</code>，即表面这是在ink!所识别的“合约部分”。因此我们可以看到，很多<code>use xxx</code>的导入都会放到处于<code>#[ink::contract]</code>的<code>mod</code>作用域下。</p>
<p>并且当前ink!设计为，在一个<code>crate</code>包下，只能出现一个<code>#[ink::contract]</code>，因此代表着ink!认为一个合约的维度是以rust的<code>crate</code>为单位，即如果在同一个<code>crate</code>中，无论是在同一个文件（比如都在<code>lib.rs</code>下）或者是在不同的文件中定义了2个以上的被<code>#[ink::contract]</code>修饰的<code>mod</code>，例如：</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    // ...
}

#[ink::contract]
mod another_define {
    // ...
}
</code></pre>
<p>类比于solidity的：</p>
<pre><code class="language-solidity ignore">// a.sol 在同一个文件中定义多个 `contract`
contract A {

}
contract B {

}
</code></pre>
<p>那么在ink!的编译中会认为这种情况是非法的。</p>
<p>当然与之相对的，只要在当前<code>crate</code>中只有一个<code>#[ink::contract]</code>修饰的<code>mod</code>，其他<code>mod</code>该怎么正常使用就正常使用，<strong>因此ink!修饰的合约<code>crate</code>依然可以很好的做好代码隔离，增强可读性和可维护性</strong>。这个能力对于<strong>维护大型复杂合约比较重要</strong>，例如：</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    use crete::another_define::*;
}

mod another_define {
    // ...
}
</code></pre>
<p>例如如下实例：</p>
<pre><code class="language-rust ignore">mod fxck {
    use crate::erc20::Erc20;
    use ::ink_lang::Env; // 注意这里需要引入 `ink_lang::Env`
    impl Erc20 {
        pub fn tmp(&amp;self) {
            self.env().caller(); // 
        }
    }
}

#[ink::contract]
mod erc20 {
    #[ink(storage)]
    pub struct Erc20 { ... }

    impl Erc20 {
        #[ink(constructor)]
        pub fn new(initial_supply: Balance) -&gt; Self { ... }
        #[ink(message)]
        pub fn transfer(&amp;mut self, initial_supply: Balance) -&gt; Self {
            self.tmp(); // 调用在其他`mod`里定义的方法
        }
    }
}
</code></pre>
<p>这种模型可以做到一些在Solidity下做不到的代码隔离，增强可维护性。（因为Solidity的library只能用于纯函数计算）</p>
<p>总结而言，在ink!体系下：</p>
<ul>
<li>一个合约以一个<code>crate</code>的单位，一个<code>crate</code>内只能出现一个<code>#[ink::contract]</code>定义；</li>
<li><code>#[ink::contract]</code>修饰的<code>mod</code>代表合约的内容，同时也代表了<strong>合约的基础元素都必须定义到这个<code>mod</code>下</strong>；</li>
<li>除<code>#[ink::contract]</code>修饰的<code>mod</code>以外的部分（其他<code>mod</code>，函数，类型）皆遵循rust的规则，可以做好良好的代码隔离提升可维护性；</li>
<li>实践中可以将<code>#[ink::contract]</code>修饰的<code>mod</code>当做合约的入口，将实现的逻辑分散到其他<code>mod</code>下。</li>
</ul>
<p>以下使用“合约mod”表示被<code>#[ink::contract]</code>修饰的<code>mod</code></p>
<h3><a class="header" href="#storage" id="storage"><code>storage</code></a></h3>
<p>在合约mod中，一定需要定义一个结构体，且这个结构体被<code>#[ink(storage)]</code>所修饰，表示定义了该合约的存储。</p>
<p>同时这个被<code>#[ink(storage)]</code>修饰的结构体定义，<strong>也被视作一个可操作的合约实体</strong>，因此所有与合约相关的资源，类型，操作都会<strong>和这个结构体绑定在一起</strong>，当在合约调用合约的情景中，被调用的合约的类型也由这个结构体来表示。</p>
<p>因此这个结构体可以理解为是合约实体。</p>
<blockquote>
<p>虽然修饰<code>mod</code>的部分才是合约，但是因为<code>mod</code>在rust中只能代表作用域，因此为了实践使用，使用<code>#[ink(storage)]</code>修饰的结构体表示能过进行操作的合约实体。</p>
<p>在这种语境下，可以将<code>#[ink::contract]</code>修饰的<code>mod</code>理解为“开启了合约域”的概念，而<code>#[ink(storage)]</code>修饰的<code>stuct</code>是在这个合约域下的合约。</p>
</blockquote>
<p>这里ink!定义的storage的概念和Solidity中定义“存储”的概念一致，表示定义在这里的属性即是最终写到<strong>链上的状态</strong>。一切合约逻辑编写的目的最后都是为了对这里定义的状态的修改。</p>
<p>不过由于当前ink!采用使用一个结构体来承载合约状态的方案，因此当前这个合约所有的状态都只能定义在这个结构体中。当合约设计得比较大，比较复杂的时候会导致这里的可维护性下降。</p>
<p>定义storage的示例如下：</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    /// Total token supply.
    total_supply: Lazy&lt;Balance&gt;,
    /// Mapping from owner to number of owned token.
    balances: StorageHashMap&lt;AccountId, Balance&gt;,
    /// Mapping of the token amount which an account is allowed to withdraw
    /// from another account.
    allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
}
</code></pre>
<p>被<code>#[ink(storage)]</code>修饰的结构体在后文统称为合约结构体。</p>
<p>这里尤其需要注意几个特性：</p>
<ol>
<li>
<p>在该合约结构体内定义的属性的类型必须是实现过<code>SpreadLayout</code>的类型（或者更准确说是实现了<code>PackedLayout</code>的类型，因为<code>PackedLayout</code>是继承于<code>SpreadLayout</code>的定义）：</p>
<pre><code class="language-rust ignore">/// Types that can be stored to and loaded from the contract storage.
pub trait SpreadLayout {
}
</code></pre>
<blockquote>
<p>这里只能使用实现过这个trait的类型的理由很简单，因为storage和一般的类型不同，其必须含有“链”的信息在其中，因此不同的链的合约实现都必须有一个部分用于处理合约中的storage（即状态）的分配问题。</p>
<p>例如Solidity在编译过程给实际上是按storage在合约中定义的上下顺序，做偏移分配该状态的key。这里实现过<code>SpredLayout</code>或者说<code>PackedLayout</code>类型的都会有一个近似的过程来进行状态的分配。</p>
</blockquote>
<p>ink!对于一般类型已经都做过基础实现，但是<strong>对于集合类型（<code>Vec</code>，<code>HashMap</code>等）而言，由于合约的状态需要hook读写的过程</strong>，因此无法对集合类型实现这个<code>trait</code>。所以在ink!中，对标准库中常用的集合类型重新全部做了一次实现，且位于<code>#[ink(storage)]</code>修饰的结构体的属性类型，<strong>若使用集合类型时，必须使用ink!提供的集合类型</strong>。</p>
<blockquote>
<p>由于Solidity比较简陋，因此Solidity定义的存储map是无法进行遍历的。（由Solidity设计的缺陷导致）</p>
<p>ink!在设计的这块的时候进一步做了很多事情，因此ink!提供的集合类型<code>Vec</code>，<code>BTreeMap</code>，<code>HashMap</code>等等都是<strong>可以遍历</strong>的。相较于Solidity能实现的功能而言是相当大的进步。</p>
</blockquote>
</li>
<li>
<p>即便基于以上的设计，嵌套集合类型既然很难实现（因为Substrate的状态结构采用了k/v模型）。因此在设计中还是只能尽量避免嵌套集合类型。如果一定需要嵌套集合类型，需要将嵌套的层次打平（flat），将第二层的key和第一层的key合并一起，使用元组替代（相当于Substrate Runtime中的<code>double_map</code>）</p>
<pre><code class="language-Solidity ignore">// solidity
contract A {
    mapping (uint =&gt; mapping (uint =&gt; uint))
}
</code></pre>
<p>在ink!中类似的代码应该为:</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    // 注意这里的key采用了元组 `(AccountId, AccountId)`
    allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
}
</code></pre>
</li>
<li>
<p>storage中提供了一种<code>Lazy</code>的模型，允许开发者使用<code>Lazy</code>包裹一个类型，可以让状态数据在使用到的情况下再加载：</p>
<pre><code class="language-rust ignore">/// A lazy storage entity.
///
/// This loads its value from storage upon first use.
///
/// # Note
///
/// Use this if the storage field doesn't need to be loaded in some or most cases.
#[derive(Debug)]
pub struct Lazy&lt;T&gt;
where
    T: SpreadLayout,
{
    cell: LazyCell&lt;T&gt;,
}
</code></pre>
<p>使用方式：</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    /// Total token supply.
    total_supply: Lazy&lt;Balance&gt;,
}
</code></pre>
</li>
</ol>
<h3><a class="header" href="#constructormessage" id="constructormessage"><code>constructor</code>/<code>message</code></a></h3>
<p><code>constructor</code>/<code>message</code>就是触发合约状态变更的入口函数。也就是说<code>constructor</code>/<code>message</code>即是合约状态的状态转换函数。</p>
<p><code>constructor</code>/<code>message</code>只能修饰<strong>合约结构体的方法</strong>，不能用来修饰其他结构体的方法，或者其他纯函数。</p>
<p>在合约mod中，被<code>constructor</code>和<code>message</code>修饰的合约结构体的方法至少各有一个，若分别少于1个都会导致编译错误。</p>
<p>其中：</p>
<ul>
<li>
<p><code>constructor</code> 即对应着 Solidity 合约中的构造函数。当合约被部署的时候（在Contracts Pallet中当前代表着从已上传的合约代码中做<code>instantiate</code>的过程），会触发对应构造函数的调用。</p>
<blockquote>
<p>这里需要强调，构造函数的调用与合约实例化是2个概念的事情，这个过程在ink!和Contracts Pallet的协调过程中<strong>并非原子化</strong>。因此会出现构造函数没有被调用，但是合约地址会生成，也可以正常调用这个未调用过构造函数的合约实例的情况。</p>
<p>典型的例子是在调用<code>instantiate</code>的时候传入的错误编码的参数。</p>
</blockquote>
</li>
<li>
<p><code>message</code>即对应着 Solidity 合约中的 <code>public</code>/<code>external</code>等 的 call 方法。由于Rust可变/不可变方法的特性，<code>message</code>利用了<strong>这个特性来表示这个方法是否会修改合约的状态</strong>。</p>
<p>因此若<code>message</code>修饰的方法是</p>
<pre><code class="language-rust ignore">// 注意方法的第一个参数是`&amp;self`
#[ink(message)]
pub fn total_supply(&amp;self) -&gt; Balance {
    *self.total_supply
}
</code></pre>
<p>则表示这个方法的调用不会修改状态（由rust语法所控制），和以太坊一致，这类方法多用于rpc调用返回一个合约的存储，或返回一些基于存储的计算结果。</p>
<p>若修饰的是</p>
<pre><code class="language-rust ignore">// 注意方法的第一个参数是 `&amp;mut self`
pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
    let from = self.env().caller();
    self.transfer_from_to(from, to, value)
}
</code></pre>
<p>则表示这个方法的调用会修改状态，因此这个方法如果是以交易调用被打包的形式被调用执行时，会触发状态的改变。若是以rpc调用时，表示是模拟执行了一次。</p>
<p>同时在合约编译后会生成metadata.json（对应Solidity的ABI），在这个metadata中对于message部分会有一个<code>mutates</code>的字段来标示这个方法是否是可变的。</p>
</li>
</ul>
<h4><a class="header" href="#message的selector" id="message的selector">message的<code>selector</code></a></h4>
<p>Solidity对于合约方法的ABI的产生使用的是将方法名加上参数类型作为函数签名拼凑成为字符串然后做hash取前4字节。</p>
<pre><code class="language-text">call = &quot;func_name(param1_type,param2_type,...)&quot;
bytes4(keccak256(call), a, b)
</code></pre>
<p>在ink!中这种让合约区分调用触发点的概念叫做<code>selector</code>。</p>
<p>由于rust不支持函数重载，因此在ink!中采用了比较简陋的设计，直接对函数名字的字符串做hash取前4字节：</p>
<pre><code class="language-text">call = &quot;func_name&quot;
blake2_512(call)[0..4]
</code></pre>
<blockquote>
<p>笔者认为这种设计造成了其他合约语言设计的困扰。因为rust不支持重载不代表别的语言不支持重载。当前Solang将Solidity编译到Wasm的过程后，想和ink!的metadata做兼容，互相调用就会出现问题。</p>
</blockquote>
<p>另一方面<code>selector</code>也是运行开发者自己定义的</p>
<pre><pre class="playground"><code class="language-rust json">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message, selector = &quot;0xCAFEBABE&quot;)]
pub fn was_it_ten(&amp;self) -&gt; bool { ... }
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#message的payable" id="message的payable">message的<code>payable</code></a></h4>
<p>Solidity中对于方法会有一个<code>payable</code>的修饰符，用于表示这个方法可以接受一定金额。</p>
<p>因此在ink!中也提供<code>payable</code>来表示调用这个方法的同时是否可以附带转移一定的<strong>本币的金额</strong>。在ink!当前的设计中，若在调用一个非<code>payable</code>的message时同时附带了金额时，这个调用过程会认为是错误的。</p>
<p>默认情况下认为<code>paybale</code>是<code>false</code>的，只有当合约开发者指定了<code>payable</code>后才是<code>true</code>。</p>
<p>指定一个message是可调用的案例是：</p>
<pre><pre class="playground"><code class="language-rust json">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message, playable)]
pub fn was_it_ten(&amp;self) -&gt; bool { ... }
<span class="boring">}
</span></code></pre></pre>
<p>另一方面在metadata中，对于message部分会有一个<code>payable</code>的字段来标示这个方法是否是需要付费的。</p>
<h3><a class="header" href="#event" id="event"><code>event</code></a></h3>
<p><code>event</code>的概念在状态机模型中其实并不是必须的。但是由于<strong>区块链是一个异步系统</strong>，因此在发送交易去触发状态变更后，并不能马上知道变更结果，只能依赖监听某个元素来判定执行结果。<code>event</code>便是在Solidity的阶段设计的元素，这个设计同样被继承到了Substrate Runtime中，以及ink!中。</p>
<blockquote>
<p>笔者不觉得event是一个很好的设计，理论上有其他更好的方式，或者event的变种。event一定程度上会造成开发者的滥用。</p>
</blockquote>
<p>ink!的<code>event</code>在Contracts Pallet中最后是通过<code>host function</code>将合约定义的event打印到了链的event当中。</p>
<p>ink!的event设计和Solidity相比就没有什么特别的地方了，不过由于是在Wasm中运行的合约，因此打印合约的event需要通过<code>host function</code>与链进行交互，因此调用的方式需要通过<code>env()</code>去调用。</p>
<pre><code class="language-rust ignore">Self::env().emit_event(...);
// or use
self.env().emit_event(...);
</code></pre>
<h1><a class="header" href="#ink-跨合约调用" id="ink-跨合约调用">ink! 跨合约调用</a></h1>
<h1><a class="header" href="#ink-与solidity的对比" id="ink-与solidity的对比">ink! 与solidity的对比</a></h1>
<h1><a class="header" href="#cargo-contract" id="cargo-contract">cargo-contract</a></h1>
<h1><a class="header" href="#ink-当前的坑" id="ink-当前的坑">ink! 当前的坑</a></h1>
<h1><a class="header" href="#ask-介绍" id="ask-介绍">Ask! 介绍</a></h1>
<h1><a class="header" href="#solang" id="solang">Solang</a></h1>
<h1><a class="header" href="#redspot" id="redspot">Redspot</a></h1>
<h1><a class="header" href="#redspot-tutorial" id="redspot-tutorial">Redspot tutorial</a></h1>
<h1><a class="header" href="#控制台console" id="控制台console">控制台console</a></h1>
<p>Redspot 提供了一个功能强大的控制台，允许开发者简单的使用命令与合约做操作，或调用位于<code>scripts</code>目录下的脚本做机械化的重复工作等等。</p>
<p>Redspot 的控制台还有很多丰富的特性：</p>
<ul>
<li>提供了<strong>强大的tab补全</strong>能力</li>
<li>控制台记录了命令历史，开发者能够查看<code>cache/console-history.txt</code>文件获取历史执行过的命令，也可以通过<code>↑</code>按键找到需要的历史命令。将来控制台也会提供快捷键索引历史命令的功能。</li>
</ul>
<h2><a class="header" href="#启动控制台" id="启动控制台">启动控制台</a></h2>
<pre><code class="language-bash">$ npx redspot console
# 若已经确定在`artifacts`目录下编译好的合约符合自己预期，则可以加上 --no-compile 参数不进行合约编译
$ npx redspot console --no-compile
</code></pre>
<p>此时执行<code>.help</code>命令可以看到相应的帮助：</p>
<pre><code class="language-bash">&gt; .help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the repl
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file
&gt; 
</code></pre>
<h2><a class="header" href="#常用命令" id="常用命令">常用命令</a></h2>
<p>控制台默认导入了<code>redspot</code>库下的供合约交互的组件，如</p>
<ul>
<li><code>patract</code></li>
<li><code>network</code> </li>
<li>...</li>
</ul>
<p>与在<code>scripts</code>目录下的脚本一致，通过这些组件可以调用许多功能，如和合约交互，查询信息，查看网络等等。</p>
<h3><a class="header" href="#常用工作流" id="常用工作流">常用工作流</a></h3>
<p>举例：当前想要调试erc20合约。那么在合约编译好后，可以在<code>artifacts</code>目录下看到<code>erc20.json</code>和<code>erc20.wasm</code>文件。加载合约相关的操作需要以这里的文件名为标示。</p>
<p>例如如果仿照<code>scripts</code>目录下的<code>deploy.ts</code>部署脚本，我们可以直接在控制台执行部署合约并调用的命令：</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20'); // erc20与文件名一致
var contract = await factory.deployed('new', 10000000); // 上传代码并实例化这个合约
</code></pre>
<p>如果是已知一个合约的地址，想在先加载这个合约实例则可以通过：</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20'); // erc20与文件名一致
var contract = await factory.attach('16DHBsUan9GoedoTYJmbyBZJMmN39ZpKUPvYeAGMTXCgxLQe'); // 加载合约地址
</code></pre>
<p>此时这里的<code>contract</code>对象就是一个实例化好的对象。因此后续可以直接用这个<code>contract</code>对象与合约进行交互，例如调用一个转账功能：</p>
<pre><code class="language-typescript">var ret = await contract.transfer(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;, 100)
ret.events // 打印events的信息
</code></pre>
<p>如果是为了通过rpc调用获取执行某个方法的结果：</p>
<pre><code class="language-typescript">var ret = await contract.balanceOf(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;)
c.output.toString()
</code></pre>
<p>如果这个过程是比较固定的，则可以把以上命令写到一个文件中放到<code>scripts</code>目录下，例如命名为<code>scripts/do_something.ts</code>：</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20');
var contract = await factory.deployed('new', 10000000); 
var ret = await contract.transfer(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;, 100)
ret.events
</code></pre>
<p>然后使用以下命令即可自动化执行一系列过程：</p>
<pre><code class="language-typescript">.load scripts/do_something.ts
</code></pre>
<p>因此控制台辅助的功能如下：</p>
<p><img src="redspot/./imgs/process.jpg" alt="" /></p>
<h1><a class="header" href="#europa" id="europa">Europa</a></h1>
<h1><a class="header" href="#europa-tutorial" id="europa-tutorial">Europa tutorial</a></h1>
<h1><a class="header" href="#europa-特性" id="europa-特性">Europa 特性</a></h1>
<h1><a class="header" href="#patract" id="patract">Patract</a></h1>
<p><img src="patract/./imgs/overview.jpg" alt="overview" /></p>
<p>Patract 做的东西具体包括:</p>
<ul>
<li>
<p>在开发者端：</p>
<ul>
<li>Jupiter：独立的智能合约测试网，提供给合约开发者测试合约链的环境。</li>
<li>Ask!：AssemblyScript 版的 Ink! 合约框架，吸引 TS/JS 的开发者，给不愿意使用 rust 的合约开发者另一个选择。</li>
<li>Redspot：Wasm 合约开发工作流和脚手架：对标 Ethereum 生态中的 Tuffle/Redhat，让合约开发项目化，自动化的工具。Redspot 采用插件化设计，运行开发者添加自己设计的插件丰富 Redspot 的功能。</li>
<li>Europa：Runtime 和合约运行沙盒：对标 Ethereum 生态中的 EthereumJS/Ganache，给合约开发者提供了丰富的调试信息，便于快速开发合约。</li>
<li>Elara：实时和可扩展的波卡 API：对标 Ethereum 中的 Infura，给合约项目方提供节点的 Endpoint，不用自行搭建节点获取数据。</li>
<li>Megaclite：零知识证明的底层支持：在 Jupiter/Patract 链中提供零知识原语支持，可以允许项目方设计 zkRollup 或其他零知识相关合约。</li>
<li>Metis：Ink! 合约标准库：对标 Ethereum 中的 openzeppelin-contracts，给合约开发者提供可复用的轮子，不必从零开始编写合约代码。</li>
<li>Himalia：多语言合约 SDK：对标 Ethereum 中的 Web3J，Web3Py 等 SDK，给合约项目方提供不同语言的环境，丰富的接口与合约进行交互。</li>
<li>Leda：合约监控台：对标 Ethereum 生态中各类合约监控设施，让合约项目方随时监控合约的存储情况，代币转移情况，合约调用情况等等。</li>
<li>Carpo：专注开发合约的智能 WebIDE：对标 Ethereum 中的 Remix，但其将会是对 Patract 以上合约开发工具的集大成者。Carpo 将采用最新的 WebIDE 技术，使得云端开发无限贴近本地开发，同时完整的云端让开发者无需搭建任何开发环境即可进行开发，开箱即用的 Patract 工具链给合约开发者提供了一体化开发体验，让开发者的开发、调试、测试和部署的合约过程如丝般顺畅。</li>
</ul>
</li>
<li>
<p>在用户端包括：</p>
<ul>
<li>Patra Store：作为 Patract 平行链钱包和 DApp 生态的入口，在测试网阶段将集成一些示例应用和配套开发工具套件用法演示，帮助开发者快速开发 Wasm 合约和前端界面，帮助用户快速进入波卡新合约生态。</li>
<li>Patra Scan：专门为智能合约链优化的区块链浏览器，集成比统一的链浏览器更丰富的合约数据信息展示，增强统计和自定义的查询功能。</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
